/* automatically generated by rust-bindgen */
use crate::host::descriptor::CompatDescriptor;

pub const CONFIG_PIPE_BUFFER_SIZE: u32 = 65536;
pub const SYSCALL_IO_BUFSIZE: u32 = 10485760;
pub const SchedulerPolicyType_SP_PARALLEL_HOST_SINGLE: SchedulerPolicyType = 0;
pub const SchedulerPolicyType_SP_PARALLEL_HOST_STEAL: SchedulerPolicyType = 1;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_SINGLE: SchedulerPolicyType = 2;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_PERTHREAD: SchedulerPolicyType = 3;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_PERHOST: SchedulerPolicyType = 4;
pub type SchedulerPolicyType = ::std::os::raw::c_uint;
pub type size_t = ::std::os::raw::c_ulong;
pub type guint32 = ::std::os::raw::c_uint;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __pid_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_long;
pub type pid_t = __pid_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GQuark = guint32;
pub type ssize_t = __ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
pub type sa_family_t = ::std::os::raw::c_ushort;
pub type in_addr_t = u32;
pub type in_port_t = u16;
pub type WorkerPool = u8;
pub const _LogLevel_LOGLEVEL_UNSET: _LogLevel = 0;
pub const _LogLevel_LOGLEVEL_ERROR: _LogLevel = 1;
pub const _LogLevel_LOGLEVEL_WARNING: _LogLevel = 2;
pub const _LogLevel_LOGLEVEL_INFO: _LogLevel = 3;
pub const _LogLevel_LOGLEVEL_DEBUG: _LogLevel = 4;
pub const _LogLevel_LOGLEVEL_TRACE: _LogLevel = 5;
pub type _LogLevel = ::std::os::raw::c_uint;
pub use self::_LogLevel as LogLevel;
pub const InterposeMethod_INTERPOSE_METHOD_PTRACE: InterposeMethod = 0;
pub const InterposeMethod_INTERPOSE_METHOD_PRELOAD: InterposeMethod = 1;
pub type InterposeMethod = ::std::os::raw::c_uint;
pub const QDiscMode_Q_DISC_MODE_FIFO: QDiscMode = 0;
pub const QDiscMode_Q_DISC_MODE_ROUND_ROBIN: QDiscMode = 1;
pub type QDiscMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChildPidWatcher {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfigOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Counter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PosixFileArc {
    _unused: [u8; 0],
}
pub use self::_Status as Status;
pub const _Status_STATUS_NONE: _Status = 0;
pub const _Status_STATUS_DESCRIPTOR_ACTIVE: _Status = 1;
pub const _Status_STATUS_DESCRIPTOR_READABLE: _Status = 2;
pub const _Status_STATUS_DESCRIPTOR_WRITABLE: _Status = 4;
pub const _Status_STATUS_DESCRIPTOR_CLOSED: _Status = 8;
pub const _Status_STATUS_FUTEX_WAKEUP: _Status = 16;
pub type _Status = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Process {
    _unused: [u8; 0],
}
pub type Process = _Process;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Host {
    _unused: [u8; 0],
}
pub type Host = _Host;
#[doc = " Simulation time in nanoseconds. Allows for a consistent representation"]
#[doc = " of time throughput the simulator."]
pub type SimulationTime = guint64;
#[doc = " Emulation time in nanoseconds. Allows for a consistent representation"]
#[doc = " of time throughput the simulator. Emulation time is the simulation time"]
#[doc = " plus the EMULATION_TIME_OFFSET. This type allows us to explicitly"]
#[doc = " distinguish each type of time in the code.,"]
pub type EmulatedTime = guint64;
extern "C" {
    pub fn return_code_for_signal(signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type LegacyDescriptor = [u64; 7usize];
pub type DescriptorCloseFunc = ::std::option::Option<
    unsafe extern "C" fn(descriptor: *mut LegacyDescriptor, host: *mut Host) -> gboolean,
>;
pub type DescriptorFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(descriptor: *mut LegacyDescriptor)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _StatusListener {
    _unused: [u8; 0],
}
pub type StatusListener = _StatusListener;
extern "C" {
    pub fn statuslistener_ref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_unref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_onStatusChanged(
        listener: *mut StatusListener,
        currentStatus: Status,
        transitions: Status,
    );
}
pub type SysCallHandler = _SysCallHandler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPU {
    _unused: [u8; 0],
}
pub type CPU = _CPU;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Timer {
    _unused: [u8; 0],
}
pub type Timer = _Timer;
pub type PluginVirtualPtr = _PluginVirtualPtr;
pub type PluginPtr = _PluginVirtualPtr;
pub type PluginPhysicalPtr = _PluginPhysicalPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PluginVirtualPtr {
    pub val: u64,
}
#[test]
fn bindgen_test_layout__PluginVirtualPtr() {
    assert_eq!(
        ::std::mem::size_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Size of: ", stringify!(_PluginVirtualPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(_PluginVirtualPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PluginVirtualPtr>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PluginVirtualPtr),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PluginPhysicalPtr {
    pub val: u64,
}
#[test]
fn bindgen_test_layout__PluginPhysicalPtr() {
    assert_eq!(
        ::std::mem::size_of::<_PluginPhysicalPtr>(),
        8usize,
        concat!("Size of: ", stringify!(_PluginPhysicalPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<_PluginPhysicalPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(_PluginPhysicalPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PluginPhysicalPtr>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PluginPhysicalPtr),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SysCallReg {
    pub as_i64: i64,
    pub as_u64: u64,
    pub as_ptr: PluginPtr,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SysCallReg() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReg>(),
        8usize,
        concat!("Size of: ", stringify!(_SysCallReg))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReg>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_i64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_ptr)
        )
    );
}
pub type SysCallReg = _SysCallReg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallArgs {
    pub number: ::std::os::raw::c_long,
    pub args: [SysCallReg; 6usize],
}
#[test]
fn bindgen_test_layout__SysCallArgs() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallArgs>(),
        56usize,
        concat!("Size of: ", stringify!(_SysCallArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallArgs>())).number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallArgs),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallArgs>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallArgs),
            "::",
            stringify!(args)
        )
    );
}
pub type SysCallArgs = _SysCallArgs;
pub const SysCallReturnState_SYSCALL_DONE: SysCallReturnState = 0;
pub const SysCallReturnState_SYSCALL_BLOCK: SysCallReturnState = 1;
pub const SysCallReturnState_SYSCALL_NATIVE: SysCallReturnState = 2;
pub type SysCallReturnState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysCallCondition {
    _unused: [u8; 0],
}
pub type SysCallCondition = _SysCallCondition;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallReturn {
    pub state: SysCallReturnState,
    pub retval: SysCallReg,
    pub cond: *mut SysCallCondition,
}
#[test]
fn bindgen_test_layout__SysCallReturn() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReturn>(),
        24usize,
        concat!("Size of: ", stringify!(_SysCallReturn))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReturn>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReturn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).cond as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(cond)
        )
    );
}
pub type SysCallReturn = _SysCallReturn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Thread {
    _unused: [u8; 0],
}
pub type Thread = _Thread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemBlock {
    pub p: *mut ::std::os::raw::c_void,
    pub nbytes: size_t,
}
#[test]
fn bindgen_test_layout__ShMemBlock() {
    assert_eq!(
        ::std::mem::size_of::<_ShMemBlock>(),
        16usize,
        concat!("Size of: ", stringify!(_ShMemBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<_ShMemBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(_ShMemBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ShMemBlock>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ShMemBlock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ShMemBlock>())).nbytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ShMemBlock),
            "::",
            stringify!(nbytes)
        )
    );
}
pub type ShMemBlock = _ShMemBlock;
extern "C" {
    pub fn thread_ref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_unref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_run(
        thread: *mut Thread,
        argv: *mut *mut ::std::os::raw::c_char,
        envv: *mut *mut ::std::os::raw::c_char,
        workingDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn thread_resume(thread: *mut Thread);
}
extern "C" {
    pub fn thread_handleProcessExit(thread: *mut Thread);
}
extern "C" {
    pub fn thread_getReturnCode(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_nativeSyscall(
        thread: *mut Thread,
        n: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn thread_isRunning(thread: *mut Thread) -> bool;
}
extern "C" {
    pub fn thread_getProcessId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getHostId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getNativePid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getNativeTid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getID(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_clone(
        thread: *mut Thread,
        flags: ::std::os::raw::c_ulong,
        child_stack: PluginPtr,
        ptid: PluginPtr,
        ctid: PluginPtr,
        newtls: ::std::os::raw::c_ulong,
        child: *mut *mut Thread,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_setTidAddress(thread: *mut Thread, addr: PluginVirtualPtr);
}
extern "C" {
    pub fn thread_getTidAddress(thread: *mut Thread) -> PluginVirtualPtr;
}
extern "C" {
    pub fn thread_isLeader(thread: *mut Thread) -> bool;
}
extern "C" {
    pub fn thread_getIPCBlock(thread: *mut Thread) -> *mut ShMemBlock;
}
extern "C" {
    pub fn thread_getShMBlock(thread: *mut Thread) -> *mut ShMemBlock;
}
extern "C" {
    pub fn thread_getProcess(thread: *mut Thread) -> *mut Process;
}
extern "C" {
    pub fn thread_getHost(thread: *mut Thread) -> *mut Host;
}
extern "C" {
    pub fn thread_getSysCallHandler(thread: *mut Thread) -> *mut SysCallHandler;
}
extern "C" {
    pub fn process_new(
        host: *mut Host,
        processID: guint,
        startTime: SimulationTime,
        stopTime: SimulationTime,
        interposeMethod: InterposeMethod,
        hostName: *const gchar,
        pluginName: *const gchar,
        pluginPath: *const gchar,
        envv: *mut *mut gchar,
        argv: *mut *mut gchar,
    ) -> *mut Process;
}
extern "C" {
    pub fn process_ref(proc_: *mut Process);
}
extern "C" {
    pub fn process_unref(proc_: *mut Process);
}
extern "C" {
    pub fn process_schedule(proc_: *mut Process, nothing: gpointer);
}
extern "C" {
    pub fn process_continue(proc_: *mut Process, thread: *mut Thread);
}
extern "C" {
    pub fn process_stop(proc_: *mut Process);
}
extern "C" {
    pub fn process_detachPlugin(procptr: gpointer, nothing: gpointer);
}
extern "C" {
    pub fn process_getWorkingDir(proc_: *mut Process) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn process_addThread(proc_: *mut Process, thread: *mut Thread);
}
extern "C" {
    pub fn process_markAsExiting(proc_: *mut Process);
}
extern "C" {
    pub fn process_isRunning(proc_: *mut Process) -> gboolean;
}
extern "C" {
    pub fn process_getName(proc_: *mut Process) -> *const gchar;
}
extern "C" {
    pub fn process_getPluginName(proc_: *mut Process) -> *const gchar;
}
extern "C" {
    pub fn process_getProcessID(proc_: *mut Process) -> guint;
}
extern "C" {
    pub fn process_getNativePid(proc_: *const Process) -> pid_t;
}
extern "C" {
    pub fn process_findNativeTID(
        proc_: *mut Process,
        virtualPID: pid_t,
        virtualTID: pid_t,
    ) -> pid_t;
}
extern "C" {
    pub fn process_registerCompatDescriptor(
        proc_: *mut Process,
        compatDesc: *mut CompatDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_deregisterCompatDescriptor(
        proc_: *mut Process,
        handle: ::std::os::raw::c_int,
    ) -> *mut CompatDescriptor;
}
extern "C" {
    pub fn process_getRegisteredCompatDescriptor(
        proc_: *mut Process,
        handle: ::std::os::raw::c_int,
    ) -> *const CompatDescriptor;
}
extern "C" {
    pub fn process_registerLegacyDescriptor(
        proc_: *mut Process,
        desc: *mut LegacyDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_deregisterLegacyDescriptor(proc_: *mut Process, desc: *mut LegacyDescriptor);
}
extern "C" {
    pub fn process_getRegisteredLegacyDescriptor(
        proc_: *mut Process,
        handle: ::std::os::raw::c_int,
    ) -> *mut LegacyDescriptor;
}
extern "C" {
    pub fn process_getPhysicalAddress(
        proc_: *mut Process,
        vPtr: PluginVirtualPtr,
    ) -> PluginPhysicalPtr;
}
extern "C" {
    pub fn process_readPtr(
        proc_: *mut Process,
        dst: *mut ::std::os::raw::c_void,
        src: PluginVirtualPtr,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_getReadableString(
        process: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
        str_: *mut *const ::std::os::raw::c_char,
        strlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_readString(
        proc_: *mut Process,
        str_: *mut ::std::os::raw::c_char,
        src: PluginVirtualPtr,
        n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn process_writePtr(
        proc_: *mut Process,
        dst: PluginVirtualPtr,
        src: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_getReadablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getWriteablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getMutablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_flushPtrs(proc_: *mut Process);
}
extern "C" {
    pub fn process_freePtrsWithoutFlushing(proc_: *mut Process);
}
extern "C" {
    pub fn process_getMemoryManager(proc_: *mut Process) -> *mut MemoryManager;
}
extern "C" {
    pub fn process_setMemoryManager(proc_: *mut Process, memoryManager: *mut MemoryManager);
}
extern "C" {
    pub fn process_getHostId(proc_: *const Process) -> u32;
}
extern "C" {
    pub fn process_getInterposeMethod(proc_: *mut Process) -> InterposeMethod;
}
extern "C" {
    pub fn process_parseArgStr(
        commandLine: *const ::std::os::raw::c_char,
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn process_parseArgStrFree(
        argv: *mut *mut ::std::os::raw::c_char,
        error: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn descriptor_unref(data: gpointer);
}
extern "C" {
    pub fn descriptor_setHandle(descriptor: *mut LegacyDescriptor, handle: gint);
}
extern "C" {
    pub fn descriptor_shutdownHelper(legacyDesc: *mut LegacyDescriptor);
}
pub type Transport = _Transport;
pub type TransportFunctionTable = _TransportFunctionTable;
pub type TransportSendFunc = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut Transport,
        thread: *mut Thread,
        buffer: PluginVirtualPtr,
        nBytes: gsize,
        ip: in_addr_t,
        port: in_port_t,
    ) -> gssize,
>;
pub type TransportReceiveFunc = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut Transport,
        thread: *mut Thread,
        buffer: PluginVirtualPtr,
        nBytes: gsize,
        ip: *mut in_addr_t,
        port: *mut in_port_t,
    ) -> gssize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TransportFunctionTable {
    pub close: DescriptorCloseFunc,
    pub free: DescriptorFreeFunc,
    pub send: TransportSendFunc,
    pub receive: TransportReceiveFunc,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__TransportFunctionTable() {
    assert_eq!(
        ::std::mem::size_of::<_TransportFunctionTable>(),
        40usize,
        concat!("Size of: ", stringify!(_TransportFunctionTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_TransportFunctionTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_TransportFunctionTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TransportFunctionTable>())).close as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TransportFunctionTable),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TransportFunctionTable>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TransportFunctionTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TransportFunctionTable>())).send as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TransportFunctionTable),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TransportFunctionTable>())).receive as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TransportFunctionTable),
            "::",
            stringify!(receive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TransportFunctionTable>())).magic as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TransportFunctionTable),
            "::",
            stringify!(magic)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Transport {
    pub super_: LegacyDescriptor,
    pub vtable: *mut TransportFunctionTable,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__Transport() {
    assert_eq!(
        ::std::mem::size_of::<_Transport>(),
        72usize,
        concat!("Size of: ", stringify!(_Transport))
    );
    assert_eq!(
        ::std::mem::align_of::<_Transport>(),
        8usize,
        concat!("Alignment of ", stringify!(_Transport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Transport>())).super_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Transport),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Transport>())).vtable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_Transport),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Transport>())).magic as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_Transport),
            "::",
            stringify!(magic)
        )
    );
}
pub use self::_ProtocolType as ProtocolType;
pub const _ProtocolType_PNONE: _ProtocolType = 0;
pub const _ProtocolType_PLOCAL: _ProtocolType = 1;
pub const _ProtocolType_PTCP: _ProtocolType = 2;
pub const _ProtocolType_PUDP: _ProtocolType = 3;
pub type _ProtocolType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Packet {
    _unused: [u8; 0],
}
pub type Packet = _Packet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Futex {
    _unused: [u8; 0],
}
pub type Futex = _Futex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FutexTable {
    _unused: [u8; 0],
}
pub type FutexTable = _FutexTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tracker {
    _unused: [u8; 0],
}
pub type Tracker = _Tracker;
pub use self::_LogInfoFlags as LogInfoFlags;
pub const _LogInfoFlags_LOG_INFO_FLAGS_NONE: _LogInfoFlags = 0;
pub const _LogInfoFlags_LOG_INFO_FLAGS_NODE: _LogInfoFlags = 1;
pub const _LogInfoFlags_LOG_INFO_FLAGS_SOCKET: _LogInfoFlags = 2;
pub const _LogInfoFlags_LOG_INFO_FLAGS_RAM: _LogInfoFlags = 4;
pub type _LogInfoFlags = i32;
pub type HostParameters = _HostParameters;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HostParameters {
    pub id: GQuark,
    pub nodeSeed: guint,
    pub hostname: *mut gchar,
    pub ipHint: *mut gchar,
    pub citycodeHint: *mut gchar,
    pub countrycodeHint: *mut gchar,
    pub requestedBWDownKiBps: guint64,
    pub requestedBWUpKiBps: guint64,
    pub cpuFrequency: guint64,
    pub cpuThreshold: guint64,
    pub cpuPrecision: guint64,
    pub heartbeatInterval: SimulationTime,
    pub heartbeatLogLevel: LogLevel,
    pub heartbeatLogInfo: LogInfoFlags,
    pub logLevel: LogLevel,
    pub pcapDir: *mut gchar,
    pub qdisc: QDiscMode,
    pub recvBufSize: guint64,
    pub autotuneRecvBuf: gboolean,
    pub sendBufSize: guint64,
    pub autotuneSendBuf: gboolean,
    pub interfaceBufSize: guint64,
}
#[test]
fn bindgen_test_layout__HostParameters() {
    assert_eq!(
        ::std::mem::size_of::<_HostParameters>(),
        160usize,
        concat!("Size of: ", stringify!(_HostParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<_HostParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(_HostParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).nodeSeed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(nodeSeed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).hostname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).ipHint as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(ipHint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).citycodeHint as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(citycodeHint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).countrycodeHint as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(countrycodeHint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).requestedBWDownKiBps as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(requestedBWDownKiBps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).requestedBWUpKiBps as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(requestedBWUpKiBps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).cpuFrequency as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(cpuFrequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).cpuThreshold as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(cpuThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).cpuPrecision as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(cpuPrecision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).heartbeatInterval as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(heartbeatInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).heartbeatLogLevel as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(heartbeatLogLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).heartbeatLogInfo as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(heartbeatLogInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).logLevel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(logLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).pcapDir as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(pcapDir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).qdisc as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(qdisc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).recvBufSize as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(recvBufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).autotuneRecvBuf as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(autotuneRecvBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).sendBufSize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(sendBufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HostParameters>())).autotuneSendBuf as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(autotuneSendBuf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HostParameters>())).interfaceBufSize as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_HostParameters),
            "::",
            stringify!(interfaceBufSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Address {
    _unused: [u8; 0],
}
#[doc = " An Address structure holds information used to identify nodes, allowing for"]
#[doc = " easy extraction of both integer and string forms of an IP address as well as"]
#[doc = " the string hostname associated with the IP. Address is an opaque structure and"]
#[doc = " should only be accessed using the functions in this class."]
pub type Address = _Address;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Router {
    _unused: [u8; 0],
}
pub type Router = _Router;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NetworkInterface {
    _unused: [u8; 0],
}
pub type NetworkInterface = _NetworkInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DNS {
    _unused: [u8; 0],
}
pub type DNS = _DNS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Random {
    _unused: [u8; 0],
}
#[doc = " An opaque structure representing a random source."]
pub type Random = _Random;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Topology {
    _unused: [u8; 0],
}
pub type Topology = _Topology;
extern "C" {
    pub fn host_new(params: *mut HostParameters) -> *mut Host;
}
extern "C" {
    pub fn host_ref(host: *mut Host);
}
extern "C" {
    pub fn host_unref(host: *mut Host);
}
extern "C" {
    pub fn host_lock(host: *mut Host);
}
extern "C" {
    pub fn host_unlock(host: *mut Host);
}
extern "C" {
    pub fn host_setup(
        host: *mut Host,
        dns: *mut DNS,
        topology: *mut Topology,
        rawCPUFreq: guint,
        hostRootPath: *const gchar,
    );
}
extern "C" {
    pub fn host_boot(host: *mut Host);
}
extern "C" {
    pub fn host_shutdown(host: *mut Host);
}
extern "C" {
    pub fn host_getNewProcessID(host: *mut Host) -> guint;
}
extern "C" {
    pub fn host_getNewEventID(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getNewPacketID(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_addApplication(
        host: *mut Host,
        startTime: SimulationTime,
        stopTime: SimulationTime,
        interposeMethod: InterposeMethod,
        pluginName: *const gchar,
        pluginPath: *const gchar,
        envv: *mut *mut gchar,
        argv: *mut *mut gchar,
    );
}
extern "C" {
    pub fn host_detachAllPlugins(host: *mut Host);
}
extern "C" {
    pub fn host_freeAllApplications(host: *mut Host);
}
extern "C" {
    pub fn host_compare(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint;
}
extern "C" {
    pub fn host_getID(host: *mut Host) -> GQuark;
}
extern "C" {
    pub fn host_isEqual(a: *mut Host, b: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_getCPU(host: *mut Host) -> *mut CPU;
}
extern "C" {
    pub fn host_getName(host: *mut Host) -> *mut gchar;
}
extern "C" {
    pub fn host_getDefaultAddress(host: *mut Host) -> *mut Address;
}
extern "C" {
    pub fn host_getDefaultIP(host: *mut Host) -> in_addr_t;
}
extern "C" {
    pub fn host_getRandom(host: *mut Host) -> *mut Random;
}
extern "C" {
    pub fn host_getNextPacketPriority(host: *mut Host) -> gdouble;
}
extern "C" {
    pub fn host_autotuneReceiveBuffer(host: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_autotuneSendBuffer(host: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_getConfiguredRecvBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getConfiguredSendBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getUpstreamRouter(host: *mut Host, handle: in_addr_t) -> *mut Router;
}
extern "C" {
    pub fn host_returnHandleHack(handle: gint);
}
extern "C" {
    pub fn host_getTracker(host: *mut Host) -> *mut Tracker;
}
extern "C" {
    pub fn host_getLogLevel(host: *mut Host) -> LogLevel;
}
extern "C" {
    pub fn host_getDataPath(host: *mut Host) -> *const gchar;
}
extern "C" {
    pub fn host_doesInterfaceExist(host: *mut Host, interfaceIP: in_addr_t) -> gboolean;
}
extern "C" {
    pub fn host_isInterfaceAvailable(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        port: in_port_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> gboolean;
}
extern "C" {
    pub fn host_getRandomFreePort(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> in_port_t;
}
extern "C" {
    pub fn host_getFutexTable(host: *mut Host) -> *mut FutexTable;
}
extern "C" {
    pub fn host_getNativeTID(host: *mut Host, virtualPID: pid_t, virtualTID: pid_t) -> pid_t;
}
extern "C" {
    pub fn worker_newForThisThread(
        worker_pool: *mut WorkerPool,
        worker_id: i32,
        bootstrap_end_time: SimulationTime,
    );
}
extern "C" {
    pub fn worker_threadID() -> i32;
}
extern "C" {
    pub fn worker_setActiveHost(host: *mut Host);
}
extern "C" {
    pub fn worker_setActiveProcess(process: *mut Process);
}
extern "C" {
    pub fn worker_setActiveThread(thread: *mut Thread);
}
extern "C" {
    pub fn worker_setRoundEndTime(t: SimulationTime);
}
extern "C" {
    pub fn worker_setCurrentTime(t: SimulationTime);
}
extern "C" {
    pub fn worker_getCurrentTime() -> SimulationTime;
}
extern "C" {
    pub fn worker_isBootstrapActive() -> bool;
}
extern "C" {
    pub fn worker_isAlive() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Task {
    _unused: [u8; 0],
}
pub type Task = _Task;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Event {
    _unused: [u8; 0],
}
pub type Event = _Event;
extern "C" {
    pub fn worker_runEvent(event: *mut Event);
}
extern "C" {
    pub fn worker_setMinEventTimeNextRound(simtime: SimulationTime);
}
extern "C" {
    pub fn worker_getAffinity() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn worker_getDNS() -> *mut DNS;
}
extern "C" {
    pub fn worker_getTopology() -> *mut Topology;
}
extern "C" {
    pub fn worker_getChildPidWatcher() -> *mut ChildPidWatcher;
}
extern "C" {
    pub fn worker_getConfig() -> *const ConfigOptions;
}
extern "C" {
    pub fn worker_scheduleTask(
        task: *mut Task,
        host: *mut Host,
        nanoDelay: SimulationTime,
    ) -> gboolean;
}
extern "C" {
    pub fn worker_sendPacket(src: *mut Host, packet: *mut Packet);
}
extern "C" {
    pub fn worker_getEmulatedTime() -> EmulatedTime;
}
extern "C" {
    pub fn worker_getNodeBandwidthUp(nodeID: GQuark, ip: in_addr_t) -> guint32;
}
extern "C" {
    pub fn worker_getNodeBandwidthDown(nodeID: GQuark, ip: in_addr_t) -> guint32;
}
extern "C" {
    pub fn worker_getLatency(sourceNodeID: GQuark, destinationNodeID: GQuark) -> gdouble;
}
extern "C" {
    pub fn worker_updateMinTimeJump(minPathLatency: gdouble);
}
extern "C" {
    pub fn worker_isFiltered(level: LogLevel) -> gboolean;
}
extern "C" {
    pub fn worker_incrementPluginError();
}
extern "C" {
    pub fn worker_resolveIPToAddress(ip: in_addr_t) -> *mut Address;
}
extern "C" {
    pub fn worker_resolveNameToAddress(name: *const gchar) -> *mut Address;
}
extern "C" {
    pub fn worker_add_syscall_counts(syscall_counts: *mut Counter);
}
extern "C" {
    pub fn affinity_getGoodWorkerAffinity() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn affinity_initPlatformInfo() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn affinity_setProcessAffinity(
        pid: pid_t,
        new_cpu_num: ::std::os::raw::c_int,
        old_cpu_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Epoll {
    _unused: [u8; 0],
}
pub type Epoll = _Epoll;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysCallHandler {
    pub host: *mut Host,
    pub process: *mut Process,
    pub thread: *mut Thread,
    pub timer: *mut Timer,
    pub epoll: *mut Epoll,
    pub blockedSyscallNR: ::std::os::raw::c_long,
    pub perfTimer: *mut GTimer,
    pub perfSecondsCurrent: gdouble,
    pub perfSecondsTotal: gdouble,
    pub numSyscalls: ::std::os::raw::c_long,
    pub syscall_counter: *mut Counter,
    pub referenceCount: ::std::os::raw::c_int,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__SysCallHandler() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallHandler>(),
        96usize,
        concat!("Size of: ", stringify!(_SysCallHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).process as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).thread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).timer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).epoll as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(epoll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).blockedSyscallNR as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(blockedSyscallNR)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).perfTimer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).perfSecondsCurrent as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfSecondsCurrent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).perfSecondsTotal as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfSecondsTotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).numSyscalls as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(numSyscalls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).syscall_counter as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(syscall_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).referenceCount as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(referenceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).magic as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(magic)
        )
    );
}
extern "C" {
    pub fn syscallhandler_close(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_dup(sys: *mut SysCallHandler, args: *const SysCallArgs) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_exit_group(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getpid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getppid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pipe(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pipe2(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pread64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pwrite64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_read(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_set_tid_address(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_uname(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_write(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
pub use self::_TriggerType as TriggerType;
pub const _TriggerType_TRIGGER_NONE: _TriggerType = 0;
pub const _TriggerType_TRIGGER_DESCRIPTOR: _TriggerType = 1;
pub const _TriggerType_TRIGGER_POSIX_FILE: _TriggerType = 2;
pub const _TriggerType_TRIGGER_FUTEX: _TriggerType = 3;
pub type _TriggerType = i32;
pub type TriggerObject = _TriggerObject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TriggerObject {
    pub as_pointer: *mut ::std::os::raw::c_void,
    pub as_descriptor: *mut LegacyDescriptor,
    pub as_file: *const PosixFileArc,
    pub as_futex: *mut Futex,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__TriggerObject() {
    assert_eq!(
        ::std::mem::size_of::<_TriggerObject>(),
        8usize,
        concat!("Size of: ", stringify!(_TriggerObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_TriggerObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_TriggerObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_descriptor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_descriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_futex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_futex)
        )
    );
}
pub type Trigger = _Trigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Trigger {
    pub type_: TriggerType,
    pub object: TriggerObject,
    pub status: Status,
}
#[test]
fn bindgen_test_layout__Trigger() {
    assert_eq!(
        ::std::mem::size_of::<_Trigger>(),
        24usize,
        concat!("Size of: ", stringify!(_Trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<_Trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_Trigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn syscallcondition_new(trigger: Trigger, timeout: *mut Timer) -> *mut SysCallCondition;
}
extern "C" {
    pub fn syscallcondition_unref(cond: *mut SysCallCondition);
}
