/* automatically generated by rust-bindgen */
use crate::host::descriptor::Descriptor;
use crate::host::descriptor::OpenFile;
use crate::host::descriptor::File;
use crate::host::descriptor::descriptor_table::DescriptorTable;
use crate::host::memory_manager::MemoryManager;
use crate::host::timer::Timer;
use crate::host::syscall::handler::SyscallHandler;
use crate::host::syscall::format::StraceFmtMode;
use crate::core::controller::Controller;
use crate::core::support::configuration::ConfigOptions;
use crate::core::support::configuration::QDiscMode;
use crate::core::work::task::TaskRef;
use crate::utility::childpid_watcher::ChildPidWatcher;
use crate::utility::counter::Counter;
use crate::utility::random::Random;
use log_bindings::Logger;
use std::sync::Arc;
use std::collections::HashSet;
use atomic_refcell::AtomicRefCell;
use crate::host::descriptor::socket::abstract_unix_ns::AbstractUnixNamespace;
type Arc_AtomicRefCell_AbstractUnixNamespace = Arc<AtomicRefCell<AbstractUnixNamespace>>;
type HashSet_String = HashSet<String>;

pub const SHADOW_SOMAXCONN: u32 = 4096;
pub const CONFIG_PIPE_BUFFER_SIZE: u32 = 65536;
pub const SYSCALL_IO_BUFSIZE: u32 = 10485760;
pub type size_t = ::std::os::raw::c_ulong;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __pid_t = ::std::os::raw::c_int;
pub type __clock_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type pid_t = __pid_t;
pub type ssize_t = __ssize_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type sigset_t = __sigset_t;
pub const _LogLevel_LOGLEVEL_UNSET: _LogLevel = 0;
pub const _LogLevel_LOGLEVEL_ERROR: _LogLevel = 1;
pub const _LogLevel_LOGLEVEL_WARNING: _LogLevel = 2;
pub const _LogLevel_LOGLEVEL_INFO: _LogLevel = 3;
pub const _LogLevel_LOGLEVEL_DEBUG: _LogLevel = 4;
pub const _LogLevel_LOGLEVEL_TRACE: _LogLevel = 5;
pub type _LogLevel = ::std::os::raw::c_uint;
pub use self::_LogLevel as LogLevel;
extern "C" {
    pub fn logger_get_global_start_time_micros() -> i64;
}
extern "C" {
    pub fn rustlogger_new() -> *mut Logger;
}
extern "C" {
    pub fn main_sidechannelMitigationsEnabled() -> bool;
}
extern "C" {
    pub fn main_checkGlibVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn main_printBuildInfo();
}
extern "C" {
    pub fn main_logBuildInfo();
}
pub const SchedulerPolicyType_SP_PARALLEL_HOST_SINGLE: SchedulerPolicyType = 0;
pub const SchedulerPolicyType_SP_PARALLEL_HOST_STEAL: SchedulerPolicyType = 1;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_SINGLE: SchedulerPolicyType = 2;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_PERTHREAD: SchedulerPolicyType = 3;
pub const SchedulerPolicyType_SP_PARALLEL_THREAD_PERHOST: SchedulerPolicyType = 4;
pub type SchedulerPolicyType = ::std::os::raw::c_uint;
extern "C" {
    pub fn runConfigHandlers(config: *const ConfigOptions);
}
pub type guint32 = ::std::os::raw::c_uint;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    fn test_field_sival_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
    }
    test_field_sival_int();
    fn test_field_sival_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    test_field_sival_ptr();
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_si_tid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_tid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_tid)
            )
        );
    }
    test_field_si_tid();
    fn test_field_si_overrun() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_overrun)
            )
        );
    }
    test_field_si_overrun();
    fn test_field_si_sigval() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(si_sigval)
            )
        );
    }
    test_field_si_sigval();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_sigval() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
                "::",
                stringify!(si_sigval)
            )
        );
    }
    test_field_si_sigval();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_status() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_status)
            )
        );
    }
    test_field_si_status();
    fn test_field_si_utime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_utime)
            )
        );
    }
    test_field_si_utime();
    fn test_field_si_stime() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
                "::",
                stringify!(si_stime)
            )
        );
    }
    test_field_si_stime();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field__lower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_lower)
            )
        );
    }
    test_field__lower();
    fn test_field__upper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(_upper)
            )
        );
    }
    test_field__upper();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    fn test_field__addr_bnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_addr_bnd)
            )
        );
    }
    test_field__addr_bnd();
    fn test_field__pkey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
                "::",
                stringify!(_pkey)
            )
        );
    }
    test_field__pkey();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    fn test_field_si_addr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(si_addr)
            )
        );
    }
    test_field_si_addr();
    fn test_field_si_addr_lsb() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(si_addr_lsb)
            )
        );
    }
    test_field_si_addr_lsb();
    fn test_field__bounds() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bounds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
                "::",
                stringify!(_bounds)
            )
        );
    }
    test_field__bounds();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    fn test_field_si_band() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
                "::",
                stringify!(si_band)
            )
        );
    }
    test_field_si_band();
    fn test_field_si_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
                "::",
                stringify!(si_fd)
            )
        );
    }
    test_field_si_fd();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    fn test_field__call_addr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_call_addr)
            )
        );
    }
    test_field__call_addr();
    fn test_field__syscall() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_syscall)
            )
        );
    }
    test_field__syscall();
    fn test_field__arch() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
                "::",
                stringify!(_arch)
            )
        );
    }
    test_field__arch();
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    fn test_field__pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_pad)
            )
        );
    }
    test_field__pad();
    fn test_field__kill() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_kill)
            )
        );
    }
    test_field__kill();
    fn test_field__timer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_timer)
            )
        );
    }
    test_field__timer();
    fn test_field__rt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_rt)
            )
        );
    }
    test_field__rt();
    fn test_field__sigchld() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigchld)
            )
        );
    }
    test_field__sigchld();
    fn test_field__sigfault() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigfault)
            )
        );
    }
    test_field__sigfault();
    fn test_field__sigpoll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigpoll)
            )
        );
    }
    test_field__sigpoll();
    fn test_field__sigsys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t__bindgen_ty_1),
                "::",
                stringify!(_sigsys)
            )
        );
    }
    test_field__sigsys();
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field___pad0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(__pad0)
            )
        );
    }
    test_field___pad0();
    fn test_field__sifields() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<siginfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(siginfo_t),
                "::",
                stringify!(_sifields)
            )
        );
    }
    test_field__sifields();
}
pub type GList = [u64; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
pub type sa_family_t = ::std::os::raw::c_ushort;
pub type in_addr_t = u32;
pub type in_port_t = u16;
pub type WorkerPool = u8;
pub type Scheduler = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Event {
    _unused: [u8; 0],
}
pub type Event = _Event;
pub type LegacyFile = [u64; 5usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Process {
    _unused: [u8; 0],
}
pub type Process = _Process;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Host {
    _unused: [u8; 0],
}
pub type Host = _Host;
#[doc = " Simulation time in nanoseconds. Allows for a consistent representation"]
#[doc = " of time throughput the simulator."]
pub type SimulationTime = guint64;
#[doc = " Emulation time in nanoseconds. Allows for a consistent representation"]
#[doc = " of time throughput the simulator. Emulation time is the simulation time"]
#[doc = " plus the EMULATION_TIME_OFFSET. This type allows us to explicitly"]
#[doc = " distinguish each type of time in the code.,"]
pub type EmulatedTime = guint64;
pub use self::_Status as Status;
pub const _Status_STATUS_NONE: _Status = 0;
pub const _Status_STATUS_FILE_ACTIVE: _Status = 1;
pub const _Status_STATUS_FILE_READABLE: _Status = 2;
pub const _Status_STATUS_FILE_WRITABLE: _Status = 4;
pub const _Status_STATUS_FILE_CLOSED: _Status = 8;
pub const _Status_STATUS_FUTEX_WAKEUP: _Status = 16;
pub const _Status_STATUS_SOCKET_ALLOWING_CONNECT: _Status = 32;
pub type _Status = i32;
extern "C" {
    pub fn return_code_for_signal(signal: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type LegacyFileCloseFunc =
    ::std::option::Option<unsafe extern "C" fn(descriptor: *mut LegacyFile, host: *mut Host)>;
pub type LegacyFileCleanupFunc =
    ::std::option::Option<unsafe extern "C" fn(descriptor: *mut LegacyFile)>;
pub type LegacyFileFreeFunc =
    ::std::option::Option<unsafe extern "C" fn(descriptor: *mut LegacyFile)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _StatusListener {
    _unused: [u8; 0],
}
pub type StatusListener = _StatusListener;
pub type HostId = GQuark;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShimShmemHost {
    _unused: [u8; 0],
}
pub type ShimShmemHost = _ShimShmemHost;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShimShmemProcess {
    _unused: [u8; 0],
}
pub type ShimShmemProcess = _ShimShmemProcess;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShimShmemThread {
    _unused: [u8; 0],
}
pub type ShimShmemThread = _ShimShmemThread;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShimHostProtectedSharedMem {
    _unused: [u8; 0],
}
pub type ShimShmemHostLock = _ShimHostProtectedSharedMem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShMemBlock {
    pub p: *mut ::std::os::raw::c_void,
    pub nbytes: size_t,
}
#[test]
fn bindgen_test_layout__ShMemBlock() {
    assert_eq!(
        ::std::mem::size_of::<_ShMemBlock>(),
        16usize,
        concat!("Size of: ", stringify!(_ShMemBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<_ShMemBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(_ShMemBlock))
    );
    fn test_field_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlock),
                "::",
                stringify!(p)
            )
        );
    }
    test_field_p();
    fn test_field_nbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ShMemBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ShMemBlock),
                "::",
                stringify!(nbytes)
            )
        );
    }
    test_field_nbytes();
}
pub type ShMemBlock = _ShMemBlock;
pub type PluginVirtualPtr = _PluginVirtualPtr;
pub type PluginPtr = _PluginVirtualPtr;
pub type PluginPhysicalPtr = _PluginPhysicalPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PluginVirtualPtr {
    pub val: u64,
}
#[test]
fn bindgen_test_layout__PluginVirtualPtr() {
    assert_eq!(
        ::std::mem::size_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Size of: ", stringify!(_PluginVirtualPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(_PluginVirtualPtr))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PluginVirtualPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_PluginVirtualPtr),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PluginPhysicalPtr {
    pub val: u64,
}
#[test]
fn bindgen_test_layout__PluginPhysicalPtr() {
    assert_eq!(
        ::std::mem::size_of::<_PluginPhysicalPtr>(),
        8usize,
        concat!("Size of: ", stringify!(_PluginPhysicalPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<_PluginPhysicalPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(_PluginPhysicalPtr))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PluginPhysicalPtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_PluginPhysicalPtr),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SysCallReg {
    pub as_i64: i64,
    pub as_u64: u64,
    pub as_ptr: PluginPtr,
}
#[test]
fn bindgen_test_layout__SysCallReg() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReg>(),
        8usize,
        concat!("Size of: ", stringify!(_SysCallReg))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReg>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReg))
    );
    fn test_field_as_i64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_i64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReg),
                "::",
                stringify!(as_i64)
            )
        );
    }
    test_field_as_i64();
    fn test_field_as_u64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_u64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReg),
                "::",
                stringify!(as_u64)
            )
        );
    }
    test_field_as_u64();
    fn test_field_as_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReg),
                "::",
                stringify!(as_ptr)
            )
        );
    }
    test_field_as_ptr();
}
pub type SysCallReg = _SysCallReg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallArgs {
    pub number: ::std::os::raw::c_long,
    pub args: [SysCallReg; 6usize],
}
#[test]
fn bindgen_test_layout__SysCallArgs() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallArgs>(),
        56usize,
        concat!("Size of: ", stringify!(_SysCallArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallArgs))
    );
    fn test_field_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallArgs),
                "::",
                stringify!(number)
            )
        );
    }
    test_field_number();
    fn test_field_args() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallArgs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallArgs),
                "::",
                stringify!(args)
            )
        );
    }
    test_field_args();
}
pub type SysCallArgs = _SysCallArgs;
pub const SysCallReturnState_SYSCALL_DONE: SysCallReturnState = 0;
pub const SysCallReturnState_SYSCALL_BLOCK: SysCallReturnState = 1;
pub const SysCallReturnState_SYSCALL_NATIVE: SysCallReturnState = 2;
pub type SysCallReturnState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysCallCondition {
    _unused: [u8; 0],
}
pub type SysCallCondition = _SysCallCondition;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallReturn {
    pub state: SysCallReturnState,
    pub retval: SysCallReg,
    pub cond: *mut SysCallCondition,
    pub restartable: bool,
}
#[test]
fn bindgen_test_layout__SysCallReturn() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReturn>(),
        32usize,
        concat!("Size of: ", stringify!(_SysCallReturn))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReturn>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReturn))
    );
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReturn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReturn),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_retval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReturn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReturn),
                "::",
                stringify!(retval)
            )
        );
    }
    test_field_retval();
    fn test_field_cond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReturn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReturn),
                "::",
                stringify!(cond)
            )
        );
    }
    test_field_cond();
    fn test_field_restartable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallReturn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).restartable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallReturn),
                "::",
                stringify!(restartable)
            )
        );
    }
    test_field_restartable();
}
pub type SysCallReturn = _SysCallReturn;
pub type SysCallHandler = _SysCallHandler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Thread {
    _unused: [u8; 0],
}
pub type Thread = _Thread;
extern "C" {
    pub fn thread_ref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_unref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_run(
        thread: *mut Thread,
        pluginPath: *mut ::std::os::raw::c_char,
        argv: *mut *mut ::std::os::raw::c_char,
        envv: *mut *mut ::std::os::raw::c_char,
        workingDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn thread_resume(thread: *mut Thread);
}
extern "C" {
    pub fn thread_handleProcessExit(thread: *mut Thread);
}
extern "C" {
    pub fn thread_getReturnCode(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_nativeSyscall(
        thread: *mut Thread,
        n: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn thread_isRunning(thread: *mut Thread) -> bool;
}
extern "C" {
    pub fn thread_getProcessId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getHostId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getNativePid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getNativeTid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getID(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_clone(
        thread: *mut Thread,
        flags: ::std::os::raw::c_ulong,
        child_stack: PluginPtr,
        ptid: PluginPtr,
        ctid: PluginPtr,
        newtls: ::std::os::raw::c_ulong,
        child: *mut *mut Thread,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_setTidAddress(thread: *mut Thread, addr: PluginVirtualPtr);
}
extern "C" {
    pub fn thread_getTidAddress(thread: *mut Thread) -> PluginVirtualPtr;
}
extern "C" {
    pub fn thread_isLeader(thread: *mut Thread) -> bool;
}
extern "C" {
    pub fn thread_getIPCBlock(thread: *mut Thread) -> *mut ShMemBlock;
}
extern "C" {
    pub fn thread_getShMBlock(thread: *mut Thread) -> *mut ShMemBlock;
}
extern "C" {
    pub fn thread_getProcess(thread: *mut Thread) -> *mut Process;
}
extern "C" {
    pub fn thread_getHost(thread: *mut Thread) -> *mut Host;
}
extern "C" {
    pub fn thread_getSysCallHandler(thread: *mut Thread) -> *mut SysCallHandler;
}
extern "C" {
    pub fn thread_getSysCallCondition(thread: *mut Thread) -> *mut SysCallCondition;
}
extern "C" {
    pub fn thread_getSignalSet(thread: *mut Thread) -> *mut sigset_t;
}
extern "C" {
    pub fn thread_unblockedSignalPending(
        thread: *mut Thread,
        host_lock: *const ShimShmemHostLock,
    ) -> bool;
}
extern "C" {
    pub fn process_new(
        host: *mut Host,
        processID: guint,
        startTime: SimulationTime,
        stopTime: SimulationTime,
        hostName: *const gchar,
        pluginName: *const gchar,
        pluginPath: *const gchar,
        envv: *mut *mut gchar,
        argv: *const *const gchar,
        pause_for_debugging: bool,
    ) -> *mut Process;
}
extern "C" {
    pub fn process_ref(proc_: *mut Process);
}
extern "C" {
    pub fn process_unref(proc_: *mut Process);
}
extern "C" {
    pub fn process_schedule(proc_: *mut Process, nothing: gpointer);
}
extern "C" {
    pub fn process_continue(proc_: *mut Process, thread: *mut Thread);
}
extern "C" {
    pub fn process_stop(proc_: *mut Process);
}
extern "C" {
    pub fn process_detachPlugin(procptr: gpointer, nothing: gpointer);
}
extern "C" {
    pub fn process_getWorkingDir(proc_: *mut Process) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn process_addThread(proc_: *mut Process, thread: *mut Thread);
}
extern "C" {
    pub fn process_getThread(proc_: *mut Process, virtualTID: pid_t) -> *mut Thread;
}
extern "C" {
    pub fn process_markAsExiting(proc_: *mut Process);
}
extern "C" {
    pub fn process_hasStarted(proc_: *mut Process) -> gboolean;
}
extern "C" {
    pub fn process_isRunning(proc_: *mut Process) -> gboolean;
}
extern "C" {
    pub fn process_getName(proc_: *mut Process) -> *const gchar;
}
extern "C" {
    pub fn process_straceLoggingMode(proc_: *mut Process) -> StraceFmtMode;
}
extern "C" {
    pub fn process_getStraceFd(proc_: *mut Process) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_getPluginName(proc_: *mut Process) -> *const gchar;
}
extern "C" {
    pub fn process_getProcessID(proc_: *mut Process) -> guint;
}
extern "C" {
    pub fn process_getNativePid(proc_: *const Process) -> pid_t;
}
extern "C" {
    pub fn process_findNativeTID(
        proc_: *mut Process,
        virtualPID: pid_t,
        virtualTID: pid_t,
    ) -> pid_t;
}
extern "C" {
    pub fn process_getDescriptorTable(proc_: *mut Process) -> *mut DescriptorTable;
}
extern "C" {
    pub fn process_getPhysicalAddress(
        proc_: *mut Process,
        vPtr: PluginVirtualPtr,
    ) -> PluginPhysicalPtr;
}
extern "C" {
    pub fn process_readPtr(
        proc_: *mut Process,
        dst: *mut ::std::os::raw::c_void,
        src: PluginVirtualPtr,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_getReadableString(
        process: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
        str_: *mut *const ::std::os::raw::c_char,
        strlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_readString(
        proc_: *mut Process,
        str_: *mut ::std::os::raw::c_char,
        src: PluginVirtualPtr,
        n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn process_writePtr(
        proc_: *mut Process,
        dst: PluginVirtualPtr,
        src: *const ::std::os::raw::c_void,
        n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_getReadablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getWriteablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getMutablePtr(
        proc_: *mut Process,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_flushPtrs(proc_: *mut Process);
}
extern "C" {
    pub fn process_freePtrsWithoutFlushing(proc_: *mut Process);
}
extern "C" {
    pub fn process_getMemoryManager(proc_: *mut Process) -> *mut MemoryManager;
}
extern "C" {
    pub fn process_setMemoryManager(proc_: *mut Process, memoryManager: *mut MemoryManager);
}
extern "C" {
    pub fn process_getHostId(proc_: *const Process) -> u32;
}
extern "C" {
    pub fn process_parseArgStr(
        commandLine: *const ::std::os::raw::c_char,
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn process_parseArgStrFree(
        argv: *mut *mut ::std::os::raw::c_char,
        error: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn process_getSharedMem(proc_: *mut Process) -> *mut ShimShmemProcess;
}
extern "C" {
    pub fn process_signal(
        process: *mut Process,
        currentRunningThread: *mut Thread,
        siginfo: *const siginfo_t,
    );
}
extern "C" {
    pub fn process_getRealtimeTimer(process: *mut Process) -> *mut Timer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tsc {
    pub cyclesPerSecond: u64,
}
#[test]
fn bindgen_test_layout__Tsc() {
    assert_eq!(
        ::std::mem::size_of::<_Tsc>(),
        8usize,
        concat!("Size of: ", stringify!(_Tsc))
    );
    assert_eq!(
        ::std::mem::align_of::<_Tsc>(),
        8usize,
        concat!("Alignment of ", stringify!(_Tsc))
    );
    fn test_field_cyclesPerSecond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Tsc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cyclesPerSecond) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Tsc),
                "::",
                stringify!(cyclesPerSecond)
            )
        );
    }
    test_field_cyclesPerSecond();
}
pub type Tsc = _Tsc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPU {
    _unused: [u8; 0],
}
pub type CPU = _CPU;
extern "C" {
    pub fn legacyfile_ref(data: gpointer);
}
extern "C" {
    pub fn legacyfile_unref(data: gpointer);
}
extern "C" {
    pub fn legacyfile_close(descriptor: *mut LegacyFile, host: *mut Host);
}
extern "C" {
    pub fn legacyfile_shutdownHelper(legacyDesc: *mut LegacyFile);
}
pub type Transport = _Transport;
pub type TransportFunctionTable = _TransportFunctionTable;
pub type TransportSendFunc = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut Transport,
        thread: *mut Thread,
        buffer: PluginVirtualPtr,
        nBytes: gsize,
        ip: in_addr_t,
        port: in_port_t,
    ) -> gssize,
>;
pub type TransportReceiveFunc = ::std::option::Option<
    unsafe extern "C" fn(
        transport: *mut Transport,
        thread: *mut Thread,
        buffer: PluginVirtualPtr,
        nBytes: gsize,
        ip: *mut in_addr_t,
        port: *mut in_port_t,
    ) -> gssize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TransportFunctionTable {
    pub close: LegacyFileCloseFunc,
    pub cleanup: LegacyFileCleanupFunc,
    pub free: LegacyFileFreeFunc,
    pub send: TransportSendFunc,
    pub receive: TransportReceiveFunc,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__TransportFunctionTable() {
    assert_eq!(
        ::std::mem::size_of::<_TransportFunctionTable>(),
        48usize,
        concat!("Size of: ", stringify!(_TransportFunctionTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_TransportFunctionTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_TransportFunctionTable))
    );
    fn test_field_close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(close)
            )
        );
    }
    test_field_close();
    fn test_field_cleanup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(cleanup)
            )
        );
    }
    test_field_cleanup();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_send() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(send)
            )
        );
    }
    test_field_send();
    fn test_field_receive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).receive) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(receive)
            )
        );
    }
    test_field_receive();
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TransportFunctionTable>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_TransportFunctionTable),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Transport {
    pub super_: LegacyFile,
    pub vtable: *mut TransportFunctionTable,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__Transport() {
    assert_eq!(
        ::std::mem::size_of::<_Transport>(),
        56usize,
        concat!("Size of: ", stringify!(_Transport))
    );
    assert_eq!(
        ::std::mem::align_of::<_Transport>(),
        8usize,
        concat!("Alignment of ", stringify!(_Transport))
    );
    fn test_field_super() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Transport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Transport),
                "::",
                stringify!(super_)
            )
        );
    }
    test_field_super();
    fn test_field_vtable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Transport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_Transport),
                "::",
                stringify!(vtable)
            )
        );
    }
    test_field_vtable();
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Transport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_Transport),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
}
pub use self::_ProtocolType as ProtocolType;
pub const _ProtocolType_PNONE: _ProtocolType = 0;
pub const _ProtocolType_PLOCAL: _ProtocolType = 1;
pub const _ProtocolType_PTCP: _ProtocolType = 2;
pub const _ProtocolType_PUDP: _ProtocolType = 3;
pub type _ProtocolType = i32;
pub const ProtocolTCPFlags_PTCP_NONE: ProtocolTCPFlags = 0;
pub const ProtocolTCPFlags_PTCP_RST: ProtocolTCPFlags = 2;
pub const ProtocolTCPFlags_PTCP_SYN: ProtocolTCPFlags = 4;
pub const ProtocolTCPFlags_PTCP_ACK: ProtocolTCPFlags = 8;
pub const ProtocolTCPFlags_PTCP_SACK: ProtocolTCPFlags = 16;
pub const ProtocolTCPFlags_PTCP_FIN: ProtocolTCPFlags = 32;
pub const ProtocolTCPFlags_PTCP_DUPACK: ProtocolTCPFlags = 64;
pub type ProtocolTCPFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Packet {
    _unused: [u8; 0],
}
pub type Packet = _Packet;
pub type PacketTCPHeader = _PacketTCPHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FutexTable {
    _unused: [u8; 0],
}
pub type FutexTable = _FutexTable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Futex {
    _unused: [u8; 0],
}
pub type Futex = _Futex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Tracker {
    _unused: [u8; 0],
}
pub type Tracker = _Tracker;
pub use self::_LogInfoFlags as LogInfoFlags;
pub const _LogInfoFlags_LOG_INFO_FLAGS_NONE: _LogInfoFlags = 0;
pub const _LogInfoFlags_LOG_INFO_FLAGS_NODE: _LogInfoFlags = 1;
pub const _LogInfoFlags_LOG_INFO_FLAGS_SOCKET: _LogInfoFlags = 2;
pub const _LogInfoFlags_LOG_INFO_FLAGS_RAM: _LogInfoFlags = 4;
pub type _LogInfoFlags = i32;
pub type HostParameters = _HostParameters;
#[repr(C)]
pub struct _HostParameters {
    pub id: GQuark,
    pub nodeSeed: guint,
    pub hostname: *const gchar,
    pub nodeId: guint,
    pub ipAddr: in_addr_t,
    pub requestedBwDownBits: guint64,
    pub requestedBwUpBits: guint64,
    pub cpuFrequency: guint64,
    pub cpuThreshold: guint64,
    pub cpuPrecision: guint64,
    pub heartbeatInterval: SimulationTime,
    pub heartbeatLogLevel: LogLevel,
    pub heartbeatLogInfo: LogInfoFlags,
    pub logLevel: LogLevel,
    pub pcapDir: *const gchar,
    pub pcapCaptureSize: guint32,
    pub qdisc: QDiscMode,
    pub recvBufSize: guint64,
    pub autotuneRecvBuf: gboolean,
    pub sendBufSize: guint64,
    pub autotuneSendBuf: gboolean,
    pub interfaceBufSize: guint64,
}
#[test]
fn bindgen_test_layout__HostParameters() {
    assert_eq!(
        ::std::mem::size_of::<_HostParameters>(),
        144usize,
        concat!("Size of: ", stringify!(_HostParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<_HostParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(_HostParameters))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_nodeSeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeSeed) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(nodeSeed)
            )
        );
    }
    test_field_nodeSeed();
    fn test_field_hostname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(hostname)
            )
        );
    }
    test_field_hostname();
    fn test_field_nodeId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nodeId) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(nodeId)
            )
        );
    }
    test_field_nodeId();
    fn test_field_ipAddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipAddr) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(ipAddr)
            )
        );
    }
    test_field_ipAddr();
    fn test_field_requestedBwDownBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requestedBwDownBits) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(requestedBwDownBits)
            )
        );
    }
    test_field_requestedBwDownBits();
    fn test_field_requestedBwUpBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requestedBwUpBits) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(requestedBwUpBits)
            )
        );
    }
    test_field_requestedBwUpBits();
    fn test_field_cpuFrequency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpuFrequency) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(cpuFrequency)
            )
        );
    }
    test_field_cpuFrequency();
    fn test_field_cpuThreshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpuThreshold) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(cpuThreshold)
            )
        );
    }
    test_field_cpuThreshold();
    fn test_field_cpuPrecision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpuPrecision) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(cpuPrecision)
            )
        );
    }
    test_field_cpuPrecision();
    fn test_field_heartbeatInterval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heartbeatInterval) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(heartbeatInterval)
            )
        );
    }
    test_field_heartbeatInterval();
    fn test_field_heartbeatLogLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heartbeatLogLevel) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(heartbeatLogLevel)
            )
        );
    }
    test_field_heartbeatLogLevel();
    fn test_field_heartbeatLogInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heartbeatLogInfo) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(heartbeatLogInfo)
            )
        );
    }
    test_field_heartbeatLogInfo();
    fn test_field_logLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logLevel) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(logLevel)
            )
        );
    }
    test_field_logLevel();
    fn test_field_pcapDir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pcapDir) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(pcapDir)
            )
        );
    }
    test_field_pcapDir();
    fn test_field_pcapCaptureSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pcapCaptureSize) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(pcapCaptureSize)
            )
        );
    }
    test_field_pcapCaptureSize();
    fn test_field_qdisc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qdisc) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(qdisc)
            )
        );
    }
    test_field_qdisc();
    fn test_field_recvBufSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recvBufSize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(recvBufSize)
            )
        );
    }
    test_field_recvBufSize();
    fn test_field_autotuneRecvBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).autotuneRecvBuf) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(autotuneRecvBuf)
            )
        );
    }
    test_field_autotuneRecvBuf();
    fn test_field_sendBufSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sendBufSize) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(sendBufSize)
            )
        );
    }
    test_field_sendBufSize();
    fn test_field_autotuneSendBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).autotuneSendBuf) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(autotuneSendBuf)
            )
        );
    }
    test_field_autotuneSendBuf();
    fn test_field_interfaceBufSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_HostParameters>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interfaceBufSize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_HostParameters),
                "::",
                stringify!(interfaceBufSize)
            )
        );
    }
    test_field_interfaceBufSize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Address {
    _unused: [u8; 0],
}
#[doc = " An Address structure holds information used to identify nodes, allowing for"]
#[doc = " easy extraction of both integer and string forms of an IP address as well as"]
#[doc = " the string hostname associated with the IP. Address is an opaque structure and"]
#[doc = " should only be accessed using the functions in this class."]
pub type Address = _Address;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Router {
    _unused: [u8; 0],
}
pub type Router = _Router;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NetworkInterface {
    _unused: [u8; 0],
}
pub type NetworkInterface = _NetworkInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DNS {
    _unused: [u8; 0],
}
pub type DNS = _DNS;
extern "C" {
    pub fn dns_new() -> *mut DNS;
}
extern "C" {
    pub fn dns_free(dns: *mut DNS);
}
extern "C" {
    pub fn dns_register(
        dns: *mut DNS,
        id: GQuark,
        name: *const gchar,
        requestedIP: in_addr_t,
    ) -> *mut Address;
}
extern "C" {
    pub fn dns_deregister(dns: *mut DNS, address: *mut Address);
}
extern "C" {
    pub fn dns_resolveIPToAddress(dns: *mut DNS, ip: in_addr_t) -> *mut Address;
}
extern "C" {
    pub fn dns_resolveNameToAddress(dns: *mut DNS, name: *const gchar) -> *mut Address;
}
extern "C" {
    pub fn dns_getHostsFilePath(dns: *mut DNS) -> *mut gchar;
}
extern "C" {
    pub fn host_new(params: *const HostParameters) -> *mut Host;
}
extern "C" {
    pub fn host_ref(host: *mut Host);
}
extern "C" {
    pub fn host_unref(host: *mut Host);
}
extern "C" {
    pub fn host_lock(host: *mut Host);
}
extern "C" {
    pub fn host_unlock(host: *mut Host);
}
extern "C" {
    pub fn host_continueExecutionTimer(host: *mut Host);
}
extern "C" {
    pub fn host_stopExecutionTimer(host: *mut Host);
}
extern "C" {
    pub fn host_setup(
        host: *mut Host,
        dns: *mut DNS,
        rawCPUFreq: gulong,
        hostRootPath: *const gchar,
    );
}
extern "C" {
    pub fn host_boot(host: *mut Host);
}
extern "C" {
    pub fn host_shutdown(host: *mut Host);
}
extern "C" {
    pub fn host_getNewProcessID(host: *mut Host) -> guint;
}
extern "C" {
    pub fn host_getNewEventID(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getNewPacketID(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_addApplication(
        host: *mut Host,
        startTime: SimulationTime,
        stopTime: SimulationTime,
        pluginName: *const gchar,
        pluginPath: *const gchar,
        envv: *const *const gchar,
        argv: *const *const gchar,
        pause_for_debugging: bool,
    );
}
extern "C" {
    pub fn host_freeAllApplications(host: *mut Host);
}
extern "C" {
    pub fn host_compare(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint;
}
extern "C" {
    pub fn host_getID(host: *mut Host) -> HostId;
}
extern "C" {
    pub fn host_isEqual(a: *mut Host, b: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_getCPU(host: *mut Host) -> *mut CPU;
}
extern "C" {
    pub fn host_getTsc(host: *mut Host) -> *mut Tsc;
}
extern "C" {
    pub fn host_getName(host: *mut Host) -> *const gchar;
}
extern "C" {
    pub fn host_getDefaultAddress(host: *mut Host) -> *mut Address;
}
extern "C" {
    pub fn host_getDefaultIP(host: *mut Host) -> in_addr_t;
}
extern "C" {
    pub fn host_getRandom(host: *mut Host) -> *mut Random;
}
extern "C" {
    pub fn host_getNextPacketPriority(host: *mut Host) -> gdouble;
}
extern "C" {
    pub fn host_autotuneReceiveBuffer(host: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_autotuneSendBuffer(host: *mut Host) -> gboolean;
}
extern "C" {
    pub fn host_getConfiguredRecvBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getConfiguredSendBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getUpstreamRouter(host: *mut Host, handle: in_addr_t) -> *mut Router;
}
extern "C" {
    pub fn host_get_bw_down_kiBps(host: *mut Host) -> u64;
}
extern "C" {
    pub fn host_get_bw_up_kiBps(host: *mut Host) -> u64;
}
extern "C" {
    pub fn host_returnHandleHack(handle: gint);
}
extern "C" {
    pub fn host_getTracker(host: *mut Host) -> *mut Tracker;
}
extern "C" {
    pub fn host_getLogLevel(host: *mut Host) -> LogLevel;
}
extern "C" {
    pub fn host_getDataPath(host: *mut Host) -> *const gchar;
}
extern "C" {
    pub fn host_doesInterfaceExist(host: *mut Host, interfaceIP: in_addr_t) -> gboolean;
}
extern "C" {
    pub fn host_isInterfaceAvailable(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        port: in_port_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> gboolean;
}
extern "C" {
    pub fn host_getRandomFreePort(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> in_port_t;
}
extern "C" {
    pub fn host_getAbstractUnixNamespace(
        host: *mut Host,
    ) -> *mut Arc_AtomicRefCell_AbstractUnixNamespace;
}
extern "C" {
    pub fn host_getFutexTable(host: *mut Host) -> *mut FutexTable;
}
extern "C" {
    pub fn host_getNativeTID(host: *mut Host, virtualPID: pid_t, virtualTID: pid_t) -> pid_t;
}
extern "C" {
    pub fn host_getProcess(host: *mut Host, virtualPID: pid_t) -> *mut Process;
}
extern "C" {
    pub fn host_getThread(host: *mut Host, virtualTID: pid_t) -> *mut Thread;
}
extern "C" {
    pub fn host_getSharedMem(host: *mut Host) -> *mut ShimShmemHost;
}
extern "C" {
    pub fn host_getShimShmemLock(host: *mut Host) -> *mut ShimShmemHostLock;
}
extern "C" {
    pub fn host_lockShimShmemLock(host: *mut Host);
}
extern "C" {
    pub fn host_unlockShimShmemLock(host: *mut Host);
}
extern "C" {
    pub fn host_getNextDeterministicSequenceValue(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn statuslistener_ref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_unref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_onStatusChanged(
        listener: *mut StatusListener,
        currentStatus: Status,
        transitions: Status,
    );
}
extern "C" {
    pub fn scheduler_new(
        controller: *const Controller,
        pidWatcher: *const ChildPidWatcher,
        config: *const ConfigOptions,
        policyType: SchedulerPolicyType,
        nWorkers: guint,
        schedulerSeed: guint,
        endTime: SimulationTime,
    ) -> *mut Scheduler;
}
extern "C" {
    pub fn scheduler_unref(arg1: *mut Scheduler);
}
extern "C" {
    pub fn scheduler_shutdown(scheduler: *mut Scheduler);
}
extern "C" {
    pub fn scheduler_start(arg1: *mut Scheduler);
}
extern "C" {
    pub fn scheduler_continueNextRound(
        arg1: *mut Scheduler,
        arg2: SimulationTime,
        arg3: SimulationTime,
    );
}
extern "C" {
    pub fn scheduler_awaitNextRound(arg1: *mut Scheduler) -> SimulationTime;
}
extern "C" {
    pub fn scheduler_finish(arg1: *mut Scheduler);
}
extern "C" {
    pub fn scheduler_addHost(arg1: *mut Scheduler, arg2: *mut Host) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn worker_runEvent(event: *mut Event);
}
extern "C" {
    pub fn worker_setMinEventTimeNextRound(simtime: SimulationTime);
}
extern "C" {
    pub fn worker_setRoundEndTime(newRoundEndTime: SimulationTime);
}
extern "C" {
    pub fn worker_getAffinity() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn worker_getDNS() -> *mut DNS;
}
extern "C" {
    pub fn worker_getChildPidWatcher() -> *const ChildPidWatcher;
}
extern "C" {
    pub fn worker_getConfig() -> *const ConfigOptions;
}
extern "C" {
    pub fn worker_scheduleTaskWithDelay(
        task: *mut TaskRef,
        host: *mut Host,
        nanoDelay: SimulationTime,
    ) -> gboolean;
}
extern "C" {
    pub fn worker_scheduleTaskAtEmulatedTime(
        task: *mut TaskRef,
        host: *mut Host,
        t: EmulatedTime,
    ) -> gboolean;
}
extern "C" {
    pub fn worker_sendPacket(src: *mut Host, packet: *mut Packet);
}
extern "C" {
    pub fn worker_isAlive() -> bool;
}
extern "C" {
    pub fn worker_maxEventRunaheadTime(host: *mut Host) -> EmulatedTime;
}
extern "C" {
    pub fn worker_getCurrentSimulationTime() -> SimulationTime;
}
extern "C" {
    pub fn worker_getCurrentEmulatedTime() -> EmulatedTime;
}
extern "C" {
    pub fn worker_isBootstrapActive() -> bool;
}
extern "C" {
    pub fn worker_getNodeBandwidthUpKiBps(ip: in_addr_t) -> guint32;
}
extern "C" {
    pub fn worker_getNodeBandwidthDownKiBps(ip: in_addr_t) -> guint32;
}
extern "C" {
    pub fn workerpool_updateMinHostRunahead(pool: *mut WorkerPool, time: SimulationTime);
}
extern "C" {
    pub fn worker_getLatencyForAddresses(
        sourceAddress: *mut Address,
        destinationAddress: *mut Address,
    ) -> SimulationTime;
}
extern "C" {
    pub fn worker_getReliabilityForAddresses(
        sourceAddress: *mut Address,
        destinationAddress: *mut Address,
    ) -> gdouble;
}
extern "C" {
    pub fn worker_isRoutable(sourceAddress: *mut Address, destinationAddress: *mut Address)
        -> bool;
}
extern "C" {
    pub fn worker_incrementPacketCount(
        sourceAddress: *mut Address,
        destinationAddress: *mut Address,
    );
}
extern "C" {
    pub fn worker_clearCurrentTime();
}
extern "C" {
    pub fn worker_setCurrentEmulatedTime(time: EmulatedTime);
}
extern "C" {
    pub fn worker_isFiltered(level: LogLevel) -> gboolean;
}
extern "C" {
    pub fn worker_incrementPluginError();
}
extern "C" {
    pub fn worker_resolveIPToAddress(ip: in_addr_t) -> *mut Address;
}
extern "C" {
    pub fn worker_resolveNameToAddress(name: *const gchar) -> *mut Address;
}
extern "C" {
    pub fn affinity_getGoodWorkerAffinity() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn affinity_initPlatformInfo() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn affinity_setProcessAffinity(
        pid: pid_t,
        new_cpu_num: ::std::os::raw::c_int,
        old_cpu_num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Epoll {
    _unused: [u8; 0],
}
pub type Epoll = _Epoll;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallHandler {
    pub host: *mut Host,
    pub process: *mut Process,
    pub thread: *mut Thread,
    pub syscall_handler_rs: *mut SyscallHandler,
    pub epoll: *mut Epoll,
    pub blockedSyscallNR: ::std::os::raw::c_long,
    pub perfTimer: *mut GTimer,
    pub perfSecondsCurrent: gdouble,
    pub perfSecondsTotal: gdouble,
    pub numSyscalls: ::std::os::raw::c_long,
    pub syscall_counter: *mut Counter,
    pub havePendingResult: bool,
    pub pendingResult: SysCallReturn,
    pub referenceCount: ::std::os::raw::c_int,
    pub magic: guint,
}
#[test]
fn bindgen_test_layout__SysCallHandler() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallHandler>(),
        136usize,
        concat!("Size of: ", stringify!(_SysCallHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallHandler))
    );
    fn test_field_host() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(host)
            )
        );
    }
    test_field_host();
    fn test_field_process() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).process) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(process)
            )
        );
    }
    test_field_process();
    fn test_field_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(thread)
            )
        );
    }
    test_field_thread();
    fn test_field_syscall_handler_rs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syscall_handler_rs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(syscall_handler_rs)
            )
        );
    }
    test_field_syscall_handler_rs();
    fn test_field_epoll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).epoll) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(epoll)
            )
        );
    }
    test_field_epoll();
    fn test_field_blockedSyscallNR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockedSyscallNR) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(blockedSyscallNR)
            )
        );
    }
    test_field_blockedSyscallNR();
    fn test_field_perfTimer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perfTimer) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(perfTimer)
            )
        );
    }
    test_field_perfTimer();
    fn test_field_perfSecondsCurrent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perfSecondsCurrent) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(perfSecondsCurrent)
            )
        );
    }
    test_field_perfSecondsCurrent();
    fn test_field_perfSecondsTotal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perfSecondsTotal) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(perfSecondsTotal)
            )
        );
    }
    test_field_perfSecondsTotal();
    fn test_field_numSyscalls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numSyscalls) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(numSyscalls)
            )
        );
    }
    test_field_numSyscalls();
    fn test_field_syscall_counter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).syscall_counter) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(syscall_counter)
            )
        );
    }
    test_field_syscall_counter();
    fn test_field_havePendingResult() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).havePendingResult) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(havePendingResult)
            )
        );
    }
    test_field_havePendingResult();
    fn test_field_pendingResult() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pendingResult) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(pendingResult)
            )
        );
    }
    test_field_pendingResult();
    fn test_field_referenceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).referenceCount) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(referenceCount)
            )
        );
    }
    test_field_referenceCount();
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SysCallHandler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(_SysCallHandler),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
}
extern "C" {
    pub fn syscallhandler_fcntl(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_ioctl(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_exit_group(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getpid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getppid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pread64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pwrite64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_read(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_set_tid_address(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_uname(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_write(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_accept(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_accept4(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_bind(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_connect(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getpeername(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getsockname(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getsockopt(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_listen(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_recvfrom(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_sendto(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_setsockopt(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_shutdown(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_socket(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_socketpair(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
pub use self::_TriggerType as TriggerType;
pub const _TriggerType_TRIGGER_NONE: _TriggerType = 0;
pub const _TriggerType_TRIGGER_DESCRIPTOR: _TriggerType = 1;
pub const _TriggerType_TRIGGER_FILE: _TriggerType = 2;
pub const _TriggerType_TRIGGER_FUTEX: _TriggerType = 3;
pub type _TriggerType = i32;
pub type TriggerObject = _TriggerObject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TriggerObject {
    pub as_pointer: *mut ::std::os::raw::c_void,
    pub as_legacy_file: *mut LegacyFile,
    pub as_file: *const File,
    pub as_futex: *mut Futex,
}
#[test]
fn bindgen_test_layout__TriggerObject() {
    assert_eq!(
        ::std::mem::size_of::<_TriggerObject>(),
        8usize,
        concat!("Size of: ", stringify!(_TriggerObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_TriggerObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_TriggerObject))
    );
    fn test_field_as_pointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TriggerObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_pointer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_TriggerObject),
                "::",
                stringify!(as_pointer)
            )
        );
    }
    test_field_as_pointer();
    fn test_field_as_legacy_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TriggerObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_legacy_file) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_TriggerObject),
                "::",
                stringify!(as_legacy_file)
            )
        );
    }
    test_field_as_legacy_file();
    fn test_field_as_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TriggerObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_file) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_TriggerObject),
                "::",
                stringify!(as_file)
            )
        );
    }
    test_field_as_file();
    fn test_field_as_futex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_TriggerObject>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_futex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_TriggerObject),
                "::",
                stringify!(as_futex)
            )
        );
    }
    test_field_as_futex();
}
pub type Trigger = _Trigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Trigger {
    pub type_: TriggerType,
    pub object: TriggerObject,
    pub status: Status,
}
#[test]
fn bindgen_test_layout__Trigger() {
    assert_eq!(
        ::std::mem::size_of::<_Trigger>(),
        24usize,
        concat!("Size of: ", stringify!(_Trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<_Trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_Trigger))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Trigger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Trigger),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Trigger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_Trigger),
                "::",
                stringify!(object)
            )
        );
    }
    test_field_object();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Trigger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_Trigger),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
extern "C" {
    pub fn syscallcondition_new(trigger: Trigger) -> *mut SysCallCondition;
}
extern "C" {
    pub fn syscallcondition_setActiveFile(cond: *mut SysCallCondition, file: *mut OpenFile);
}
extern "C" {
    pub fn syscallcondition_unref(cond: *mut SysCallCondition);
}
extern "C" {
    pub fn syscallcondition_getActiveFile(cond: *mut SysCallCondition) -> *mut OpenFile;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PacketTCPHeader {
    pub flags: ProtocolTCPFlags,
    pub sourceIP: in_addr_t,
    pub sourcePort: in_port_t,
    pub destinationIP: in_addr_t,
    pub destinationPort: in_port_t,
    pub sequence: guint,
    pub acknowledgment: guint,
    pub selectiveACKs: *mut GList,
    pub window: guint,
    pub timestampValue: SimulationTime,
    pub timestampEcho: SimulationTime,
}
#[test]
fn bindgen_test_layout__PacketTCPHeader() {
    assert_eq!(
        ::std::mem::size_of::<_PacketTCPHeader>(),
        64usize,
        concat!("Size of: ", stringify!(_PacketTCPHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_PacketTCPHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_PacketTCPHeader))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_sourceIP() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourceIP) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(sourceIP)
            )
        );
    }
    test_field_sourceIP();
    fn test_field_sourcePort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sourcePort) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(sourcePort)
            )
        );
    }
    test_field_sourcePort();
    fn test_field_destinationIP() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destinationIP) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(destinationIP)
            )
        );
    }
    test_field_destinationIP();
    fn test_field_destinationPort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destinationPort) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(destinationPort)
            )
        );
    }
    test_field_destinationPort();
    fn test_field_sequence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(sequence)
            )
        );
    }
    test_field_sequence();
    fn test_field_acknowledgment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).acknowledgment) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(acknowledgment)
            )
        );
    }
    test_field_acknowledgment();
    fn test_field_selectiveACKs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).selectiveACKs) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(selectiveACKs)
            )
        );
    }
    test_field_selectiveACKs();
    fn test_field_window() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(window)
            )
        );
    }
    test_field_window();
    fn test_field_timestampValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestampValue) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(timestampValue)
            )
        );
    }
    test_field_timestampValue();
    fn test_field_timestampEcho() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_PacketTCPHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestampEcho) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_PacketTCPHeader),
                "::",
                stringify!(timestampEcho)
            )
        );
    }
    test_field_timestampEcho();
}
extern "C" {
    pub fn packet_getTotalSize(packet: *const Packet) -> gsize;
}
extern "C" {
    pub fn packet_getPayloadSize(packet: *const Packet) -> gsize;
}
extern "C" {
    pub fn packet_getHeaderSize(packet: *const Packet) -> gsize;
}
extern "C" {
    pub fn packet_getDestinationIP(packet: *const Packet) -> in_addr_t;
}
extern "C" {
    pub fn packet_getDestinationPort(packet: *const Packet) -> in_port_t;
}
extern "C" {
    pub fn packet_getSourceIP(packet: *const Packet) -> in_addr_t;
}
extern "C" {
    pub fn packet_getSourcePort(packet: *const Packet) -> in_port_t;
}
extern "C" {
    pub fn packet_getProtocol(packet: *const Packet) -> ProtocolType;
}
extern "C" {
    pub fn packet_copyPayloadShadow(
        packet: *const Packet,
        payloadOffset: gsize,
        buffer: *mut ::std::os::raw::c_void,
        bufferLength: gsize,
    ) -> guint;
}
extern "C" {
    pub fn packet_getTCPHeader(packet: *const Packet) -> *mut PacketTCPHeader;
}
extern "C" {
    pub fn scanRpathForLib(libname: *const gchar) -> *mut gchar;
}
