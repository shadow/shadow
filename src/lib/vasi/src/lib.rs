// For use by code generated by vasi_macro::VirtualAddressSpaceIndependent;
#[doc(hidden)]
pub use static_assertions::assert_impl_all;

pub use vasi_macro::VirtualAddressSpaceIndependent;

/// SAFETY: Instances of types implementing this trait are safe to access from
/// other virtual address spaces. Typically this requires containing no
/// references, and either containing no raw pointers, or ensuring that those
/// pointers aren't dereferenced outside of their original virtual address
/// space. *Relative* pointers, e.g. as implemented in
/// [rkyv](https://crates.io/crates/rkyv), are acceptable as long as they point
/// within the boundaries of the enclosing
/// type.
///
/// This trait is intended as a marker for types that can be safely kept in
/// shared memory, and potentially mapped to different virtual addresses in
/// different processes, (as long as the "root" value in shared memory is also
/// [std::marker::Sync]).
pub unsafe trait VirtualAddressSpaceIndependent {}

// Types not containing any pointers are trivially VirtualAddressSpaceIndependent.
unsafe impl VirtualAddressSpaceIndependent for i32 {}
unsafe impl VirtualAddressSpaceIndependent for u32 {}
unsafe impl VirtualAddressSpaceIndependent for i64 {}
unsafe impl VirtualAddressSpaceIndependent for u64 {}
unsafe impl VirtualAddressSpaceIndependent for usize {}
unsafe impl VirtualAddressSpaceIndependent for isize {}
unsafe impl VirtualAddressSpaceIndependent for bool {}

// "This type has the same in-memory representation as the underlying integer type, u64"
unsafe impl VirtualAddressSpaceIndependent for std::sync::atomic::AtomicU64 {}
