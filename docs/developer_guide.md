# Debugging and profiling

## Extra tests

Shadow includes tests that require additional dependencies, such as Tor, TGen,
networkx, and golang. These aren't run by default, but are run as part of the CI tests.

To run them locally, first make sure that both tor and tgen are located at
`~/.local/bin/{tor,tgen}`. These can be symlinks to tor and tgen binaries
elsewhere in the filesystem. You should also install all of Shadow's optional
dependencies.

To run the golang tests you will need to both install golang, and install
a dynamic version of the golang standard library. The latter can be done with
`go install -buildmode=shared -linkshared std`.

It is recommended to build Shadow in release mode, otherwise the Tor tests may
not complete before the timeout.

```bash
./setup build --test --extra
./setup test --extra
# To exclude the Tor tests (for example if you built Shadow in debug mode)
./setup test --extra -- --label-exclude tor
```

If you change the version of tor located at `~/.local/bin/tor`, make sure to
re-run `./setup build --test`.

## Debugging

### Debugging the Shadow process

Shadow is currently built with debugging symbols in both debug and release
builds, though it may be easier to debug a debug build (generated by passing
the `--debug` flag to `setup build`).

Shadow can be run under GDB by prepending `gdb --args` to its command-line.
e.g.:

```
gdb --args shadow shadow.yaml
```

An alternative is to run Shadow with the `--gdb` flag, which will pause shadow
after startup and print its PID. You can then simply attach GDB to Shadow in a
new terminal and continue the experiment.

Example:

```
# terminal 1
# shadow will print its PID and pause
$ shadow --gdb shadow.yaml > shadow.log
** Starting Shadow
** Pausing with SIGTSTP to enable debugger attachment (pid 1234)

# terminal 2
$ gdb --pid=1234
> continue
```

### Debugging managed processes

A simulation's managed processes are implemented as native OS processes, with
their syscalls interposed by Shadow. Since they are native processes, many
normal tools for inspecting native processes can be used on those as well. e.g.
`top` will show how much CPU and memory they are using.

#### Generating a core file

If a managed process is crashing, it is sometimes easiest to let the native
process to generate a core file, and then use GDB to inspect it afterwards.

```
# Enable core dumps.
ulimit -c unlimited

# Run the simulation in which a process is crashing.
shadow shadow.yaml

# Tell gdb to inspect the core file. From within gdb you'll be able to
# inspect the state of the process when it was killed.
gdb <path-to-process-executable> <path-to-core-file>
```

#### Attaching with GDB

You can attach GDB directly to the managed process. To make this easier you can
use the `--debug-hosts` option to pause Shadow after it launches each managed
process on the given hosts. Shadow will print the native process' PID before
stopping. For example, `--debug-hosts client,server` will pause Shadow after
launching any managed processees on hosts "client" and "server". This allows
you to attach GDB directly to those managed processes before resuming Shadow.

```
# terminal 1
$ shadow --debug-hosts client,server shadow.yaml > shadow.log
** Starting Shadow
** Pausing with SIGTSTP to enable debugger attachment to managed process 'server.nginx.1000' (pid 1234)
** If running Shadow under Bash, resume Shadow by pressing Ctrl-Z to background this task and then typing "fg".
** (If you wish to kill Shadow, type "kill %%" instead.)
** If running Shadow under GDB, resume Shadow by typing "signal SIGCONT".

# terminal 2
$ gdb --pid=1234
```

#### Debugging with GDB

```
# It's often useful to look at the stack backtrace:
> bt

# Or for a multi-threaded process, to look at all of the threads' backtraces:
> thread apply all bt
```

### Tracing Shadow using Valgrind

If you want to be able to run Shadow through valgrind and the application you
are running in Shadow uses OpenSSL (e.g. `tor`), you should configure OpenSSL
with the additional option: `-DPURIFY`. This fixes OpenSSL so it doesn't break
valgrind. You may also want to ensure that debugging symbols are included in the
GLib that Shadow links to, and any library used by the plug-in. This can be
achieved with the compiler flag `-g` when manually building a local version of
GLib.

### Profiling Shadow

#### Profiling with `gprof`

This method only provides profiling info for the core of Shadow, not for
plug-ins, or other libraries. Also, the profiling info is limited since gprof
only measures active CPU usage and function call counts and misses performance
related to blocking IO and barrier waits.

```bash
./setup build -cgo
./setup install
cd resource/examples
shadow shadow.config.xml > shadow.log
gprof `which shadow` gmon.out > analysis.txt
less analysis.txt
```

#### Profiling with `perf`

Either run perf when starting Shadow:

```bash
perf record shadow shadow.config.yaml > shadow.log
```

Or, connect to a running Shadow process:

```bash
perf record -p <PID>
```

Either of the above two options will write a `perf.data` file when you press
control-c, or Shadow ends. You can then analyze the report:

```bash
perf report
```

Perf is extremely powerful with many options. See `man perf` or [the perf
wiki](https://perf.wiki.kernel.org/index.php/Tutorial) for more info.

Note that any time an example uses the `-g` option in `perf record`, you should
use `--call-graph dwarf` instead. (The `-g` option defaults to stack frames for
traces, which elf-loader and certain optimizations can break. If you see
absurdly tall or small call graphs, this is probably what happened.)

### Testing for Deterministic Behavior

If you run Shadow twice with the same seed (the `-s` or `--seed` command line
options), then it _should_ produce deterministic results (it's a bug if it
doesn't).

#### Comparing strace output (experimental)

Shadow has an experimental feature for logging most system calls made by the
managed process in a format similar to the strace tool. You can enable this
with the [`strace_logging_mode` option][strace-logging-mode]. You can compare
this strace log from two simulations to look for non-deterministic behaviour.
To avoid capturing memory addresses and uninitialized memory in the log, you
should use the `deterministic` logging mode.

For example, after running two simulations with `--strace-logging-mode
deterministic` where the results are in the `shadow.data.1` and `shadow.data.2`
directories, you could run something like the following bash script:

[strace-logging-mode]: shadow_config_spec.md#experimentalstrace_logging_mode

```bash
#!/bin/bash

found_difference=0

for SUFFIX in \
    hosts/fileserver/fileserver.tgen.1000.strace \
    hosts/client/client.tgen.1000.strace
do
    diff --brief shadow.data.1/${SUFFIX} shadow.data.2/${SUFFIX}
    exit_code=$?

    if (($exit_code != 0)); then
      found_difference=1
    fi
done

if (($found_difference == 1)); then
  echo -e "\033[0;31mDetected difference in output (Shadow may be non-deterministic).\033[0m"
else
  echo -e "\033[0;32mDid not detect difference in Shadow output (Shadow may be deterministic).\033[0m"
fi
```

#### Comparing application output

A good way to check this is to compare the log output of an application that
was run in Shadow. For example, after running two TGen simulations where the
results are in the `shadow.data.1` and `shadow.data.2` directories, you could
run something like the following bash script:

```bash
#!/bin/bash

found_difference=0

for SUFFIX in \
    hosts/fileserver/fileserver.tgen.1000.stdout \
    hosts/client/client.tgen.1000.stdout
do
    ## ignore memory addresses in log file with `sed 's/0x[0-9a-f]*/HEX/g' FILENAME`
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.1/${SUFFIX}
    sed -i 's/0x[0-9a-f]*/HEX/g' shadow.data.2/${SUFFIX}

    diff --brief shadow.data.1/${SUFFIX} shadow.data.2/${SUFFIX}
    exit_code=$?

    if (($exit_code != 0)); then
      found_difference=1
    fi
done

if (($found_difference == 1)); then
  echo -e "\033[0;31mDetected difference in output (Shadow may be non-deterministic).\033[0m"
else
  echo -e "\033[0;32mDid not detect difference in Shadow output (Shadow may be deterministic).\033[0m"
fi
```

If you find non-deterministic behavior in your Shadow experiment, please
consider helping to diagnose the problem by opening a [new
issue](https://github.com/shadow/shadow/issues/new).
